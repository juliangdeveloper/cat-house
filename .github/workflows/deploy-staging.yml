name: Deploy to Staging

on:
  workflow_run:
    workflows: ["Build and Push Docker Images"]
    types:
      - completed
    branches: [ develop ]
  workflow_dispatch:

env:
  AWS_REGION: sa-east-1
  ENVIRONMENT: staging
  CLUSTER_NAME: cat-house-staging
  IMAGE_TAG: staging

jobs:
  # Run database migrations first (auth-service only)
  migrate:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Run database migrations
      env:
        DATABASE_URL: ${{ secrets.NEON_STAGING_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
        ENVIRONMENT: staging
      working-directory: cat-house-backend/auth-service
      run: |
        echo "Running database migrations via GitHub Actions..."
        
        pip install -r requirements.txt alembic
        alembic upgrade head
        
        echo "Migrations completed successfully"

  # Deploy all backend services
  deploy-backend:
    needs: migrate
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [auth-service, catalog-service, installation-service, proxy-service]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Verify Docker image exists in ECR
      run: |
        echo "Verifying that Docker image exists for ${{ matrix.service }}..."
        
        if aws ecr describe-images \
          --repository-name cat-house/${{ matrix.service }} \
          --image-ids imageTag=${{ env.IMAGE_TAG }} \
          --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
          echo "✅ Image found: cat-house/${{ matrix.service }}:${{ env.IMAGE_TAG }}"
        else
          echo "❌ ERROR: Docker image not found in ECR"
          echo "Expected image: cat-house/${{ matrix.service }}:${{ env.IMAGE_TAG }}"
          exit 1
        fi
    
    - name: Get current task definition
      id: get-task-def
      run: |
        echo "Fetching current task definition for ${{ matrix.service }}..."
        aws ecs describe-task-definition \
          --task-definition cat-house-staging-${{ matrix.service }} \
          --query 'taskDefinition' > task-def.json
    
    - name: Inject secrets and register new task definition
      id: register-task-def
      env:
        DATABASE_URL: ${{ secrets.NEON_STAGING_DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
      run: |
        echo "Injecting secrets into task definition..."
        
        # Add environment variables to task definition
        jq --arg db_url "$DATABASE_URL" \
           --arg jwt_secret "$JWT_SECRET" \
           --arg enc_key "$ENCRYPTION_KEY" \
           '.containerDefinitions[0].environment += [
             {"name":"DATABASE_URL","value":$db_url},
             {"name":"JWT_SECRET","value":$jwt_secret},
             {"name":"ENCRYPTION_KEY","value":$enc_key}
           ] | del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)' \
           task-def.json > new-task-def.json
        
        # Register new task definition
        NEW_TASK_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://new-task-def.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "task_arn=$NEW_TASK_ARN" >> $GITHUB_OUTPUT
        echo "Registered new task definition: $NEW_TASK_ARN"
    
    - name: Update ECS service
      run: |
        echo "Deploying ${{ matrix.service }} to staging..."
        
        aws ecs update-service \
          --cluster ${{ env.CLUSTER_NAME }} \
          --service cat-house-staging-${{ matrix.service }} \
          --task-definition ${{ steps.register-task-def.outputs.task_arn }} \
          --force-new-deployment
        
        echo "Service ${{ matrix.service }} deployment initiated"
    
    - name: Wait for service stability
      run: |
        echo "Waiting for ${{ matrix.service }} to become stable..."
        
        aws ecs wait services-stable \
          --cluster ${{ env.CLUSTER_NAME }} \
          --services cat-house-staging-${{ matrix.service }}
        
        echo "Service ${{ matrix.service }} is stable"
    
    - name: Verify health check
      run: |
        # Extract service name without -service suffix for health endpoint
        SERVICE_NAME=$(echo "${{ matrix.service }}" | sed 's/-service$//')
        
        # All services use the same health endpoint pattern
        HEALTH_URL="http://cat-house-staging-alb-1968126506.sa-east-1.elb.amazonaws.com/api/v1/${SERVICE_NAME}/health"
        
        echo "Health check URL: $HEALTH_URL"
        echo "Waiting for service to be fully operational..."
        
        # Retry health check up to 10 times with 15 second intervals
        for i in {1..10}; do
          echo "Attempt $i/10..."
          if curl -f -s "$HEALTH_URL" --connect-timeout 5 --max-time 10; then
            echo "✅ Health check passed for ${{ matrix.service }}"
            exit 0
          fi
          echo "Health check failed, retrying in 15s..."
          sleep 15
        done
        
        echo "❌ Health check failed after 10 attempts (2.5 minutes)"
        echo "Service may need more time to initialize or check CloudWatch logs for errors"
        exit 1

  # Deploy frontend
  deploy-frontend:
    needs: deploy-backend
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Build frontend static export
      working-directory: frontend
      env:
        EXPO_PUBLIC_API_URL: https://api-staging.gamificator.click
      run: |
        npm install --legacy-peer-deps
        npx expo export --platform web
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Sync to S3
      run: |
        echo "Syncing frontend to S3..."
        aws s3 sync frontend/dist/ s3://cat-house-frontend-staging --delete
        echo "Frontend synced to S3"
    
    - name: Invalidate CloudFront cache
      run: |
        echo "Invalidating CloudFront cache..."
        aws cloudfront create-invalidation \
          --distribution-id ${{ secrets.CLOUDFRONT_STAGING_ID }} \
          --paths "/*"
        echo "CloudFront cache invalidated"
